//\n//  StarMapViewModel.swift\n//  StarMap\n//\n//  Created by Francesco Albano on 10/08/25.\n//\nimport SwiftUI\nimport Combine\nimport CoreMotion\nimport CoreLocation\nimport SwissEphemeris\n\n@MainActor\nclass StarMapViewModel: ObservableObject {\n    // MARK: - Published Properties\n    @Published var fieldOfView: Double = AppConfig.defaultFieldOfView\n    @Published var isTrackingMode: Bool = true\n    @Published var selectedObject: (any CelestialObject)?\n    @Published var showObjectInfo: Bool = false\n    @Published var activeFilter: FilterType = .all\n    @Published var planets: [Planet]\n\n    // MARK: - Manual Camera Control\n    @Published var manualPitch: Double = 0\n    @Published var manualYaw: Double = 0\n    \n    // MARK: - Data Stores\n    let stars: [Star]\n    \n    var filteredObjects: [any CelestialObject] {\n        switch activeFilter {\n        case .all: return stars + planets\n        case .stars: return stars\n        case .planets: return planets\n        }\n    }\n    \n    // MARK: - Internal State\n    private var lastDragTranslation: CGSize = .zero\n    private var lastMagnification: CGFloat = 1.0\n    private var currentPlanetCalculationDate: Date?\n    private var currentLocation: CLLocation?\n\n    // MARK: - Initialization\n    init() {\n        JPLFileManager.setEphemerisPath()\n        \n        #if DEBUG\n        CoordinateSystemTest.runDiagnostics()\n        #endif\n        \n        self.stars = StarDataLoader.loadStaticStars(maxMagnitude: 6.5)\n        self.planets = []\n        \n        print("ViewModel initialized. Ready to load data.")\n    }\n    \n    // MARK: - Data Handling\n    \n    /// Called when the app becomes active - this triggers an immediate planet recalculation\n    func forceDataRefreshOnAppActive() {\n        print("üîÑ App became active. Forcing immediate planet recalculation.")\n        \n        // If we have a stored location, immediately recalculate planets\n        if let location = currentLocation {\n            print("üîÑ Using stored location to force planet update")\n            recalculatePlanets(for: location, forceUpdate: true)\n        } else {\n            print("‚ö†Ô∏è No location available yet - will update when location is received")\n            // Clear the date so next location update will trigger recalculation\n            currentPlanetCalculationDate = nil\n        }\n    }\n    \n    /// Called when location changes - stores location and updates planets if needed\n    func updateData(for location: CLLocation) {\n        // Always store the latest location\n        self.currentLocation = location\n        \n        // Recalculate planets with normal time-based logic\n        recalculatePlanets(for: location, forceUpdate: false)\n    }\n    \n    /// Core function that recalculates planet positions based on current date/time\n    private func recalculatePlanets(for location: CLLocation, forceUpdate: Bool) {\n        let now = Date()\n        \n        // Determine if we should update\n        let shouldUpdate: Bool\n        if forceUpdate {\n            print("üîÑ Force update requested")\n            shouldUpdate = true\n        } else if let lastCalcDate = currentPlanetCalculationDate {\n            let timeSinceLastUpdate = now.timeIntervalSince(lastCalcDate)\n            shouldUpdate = timeSinceLastUpdate >= 60.0\n            if !shouldUpdate {\n                print("‚è≠Ô∏è Skipping update - only \(Int(timeSinceLastUpdate))s since last update (need 60s)")\n            }\n        } else {\n            print("üÜï First planet calculation")\n            shouldUpdate = true\n        }\n        \n        guard shouldUpdate else {\n            return\n        }\n        \n        let julianDay = now.julianDay\n        \n        print("‚úÖ RECALCULATING planets for current date/time:")\n        print("   üìÖ Date: \(now)")\n        print("   üåç Julian Day: \(String(format: "%.5f", julianDay))")\n        \n        // Get fresh planet data with CURRENT ephemeris data\n        var freshPlanets = PlanetProvider.createPlanetsForDate(now)\n        \n        // For each planet, convert its RA/Dec to Cartesian coordinates\n        for i in 0..<freshPlanets.count {\n            let planet = freshPlanets[i]\n            \n            // Step 1: Convert equatorial (RA/Dec) to Cartesian\n            let cartesian = AstroCalculator.equatorialToCartesian(\n                ra: planet.ra,\n                dec: planet.dec\n            )\n            \n            // Step 2: Apply the celestial pole rotation (same as stars)\n            let rotationAngle = Double.pi / 2\n            let rotatedY = cartesian.y * cos(rotationAngle) - cartesian.z * sin(rotationAngle)\n            let rotatedZ = cartesian.y * sin(rotationAngle) + cartesian.z * cos(rotationAngle)\n            let rotatedPosition = CartesianCoordinates(\n                x: cartesian.x,\n                y: rotatedY,\n                z: rotatedZ\n            )\n            \n            // Step 3: Apply specular inversion (same as stars)\n            freshPlanets[i].position = CartesianCoordinates(\n                x: -rotatedPosition.x,\n                y: rotatedPosition.y,\n                z: rotatedPosition.z\n            )\n            \n            print("  ‚Ä¢ \(planet.name): RA=\(String(format: "%.4f", planet.ra))¬∞ Dec=\(String(format: "%.4f", planet.dec))¬∞")\n        }\n        \n        self.planets = freshPlanets\n        self.currentPlanetCalculationDate = now\n        \n        print("‚úÖ \(freshPlanets.count) planets updated successfully for \(now)")\n    }\n    \n    // MARK: - Camera Control\n    \n    func handleDrag(translation: CGSize, motionManager: MotionManager, locationManager: LocationManager) {\n        if isTrackingMode {\n            isTrackingMode = false\n            manualPitch = motionManager.pitch\n            manualYaw = locationManager.compassHeading.toRadians\n        }\n        \n        let deltaX = translation.width - lastDragTranslation.width\n        let deltaY = translation.height - lastDragTranslation.height\n        \n        manualYaw -= deltaX * AppConfig.dragSensitivity\n        manualPitch += deltaY * AppConfig.dragSensitivity\n        \n        lastDragTranslation = translation\n    }\n    \n    func endDrag() {\n        lastDragTranslation = .zero\n    }\n    \n    func handleZoom(magnification: CGFloat) {\n        let delta = magnification / lastMagnification\n        lastMagnification = magnification\n        fieldOfView /= delta\n        fieldOfView = max(AppConfig.minimumFieldOfView, min(AppConfig.maximumFieldOfView, fieldOfView))\n    }\n    \n    func endZoom() {\n        lastMagnification = 1.0\n    }\n    \n    func resumeTracking() {\n        withAnimation(.spring(response: 0.3)) {\n            isTrackingMode = true\n        }\n    }\n    \n    // MARK: - Object Selection\n    \n    func findClosestObject(at location: CGPoint, rotationMatrix: CMRotationMatrix?, manualPitch: Double, manualYaw: Double, screenSize: CGSize) -> (any CelestialObject)? {\n        let objectsToSearch = filteredObjects\n        let centerX = screenSize.width / 2\n        let centerY = screenSize.height / 2\n        let scale = screenSize.width / (2 * tan(fieldOfView.toRadians / 2))\n        \n        var closestObject: (any CelestialObject)? = nil\n        var minDistance: Double = AppConfig.selectionTapRadius\n        \n        for obj in objectsToSearch {\n            let rotated: CartesianCoordinates\n            if let matrix = rotationMatrix, isTrackingMode {\n                rotated = obj.position.rotatedByDeviceMatrix(matrix)\n            } else {\n                rotated = obj.position.rotated(pitch: manualPitch, yaw: manualYaw)\n            }\n            \n            if let projected = SkyRenderer.project(coordinates: rotated, screenCenter: CGPoint(x: centerX, y: centerY), scale: scale) {\n                let distance = hypot(projected.x - location.x, projected.y - location.y)\n                if distance < minDistance {\n                    minDistance = distance\n                    closestObject = obj\n                }\n            }\n        }\n        return closestObject\n    }\n    \n    func selectObject(_ object: any CelestialObject) {\n        if let planet = object as? Planet {\n            let distance = Coordinate<SwissEphemeris.Planet>(body: planet.body, date: Date()).distance\n            var updatedPlanet = planet\n            updatedPlanet.distanceAU = distance\n            self.selectedObject = updatedPlanet\n        } else {\n            self.selectedObject = object\n        }\n        self.showObjectInfo = true\n    }\n    \n    func deselectObject() {\n        withAnimation(.easeOut(duration: 0.2)) { showObjectInfo = false }\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { self.selectedObject = nil }\n    }\n}